# Пошаговое описание домашней работы по транзакциям

В этой работе мы изучили и продемонстрировали на практике ключевые концепции транзакций в PostgreSQL.

## 1. Базовые операции с транзакциями

Сначала мы рассмотрели основы управления транзакциями.

- **`BEGIN ... COMMIT`**: Мы создали транзакцию, которая успешно выполняет несколько операций (добавляет новую подписку и обновляет пользователя), а затем фиксирует все изменения в базе данных с помощью команды `COMMIT`.
- **`BEGIN ... ROLLBACK`**: Мы повторили ту же последовательность операций, но вместо фиксации отменили все изменения с помощью `ROLLBACK`. Это показало, как можно безопасно отказаться от изменений, если что-то пошло не так.
- **Автоматический откат при ошибке**: Мы намеренно вызвали ошибку в транзакции (деление на ноль). PostgreSQL автоматически прервал выполнение и откатил все изменения, сделанные внутри этой транзакции, что гарантирует целостность данных.

## 2. Уровни изоляции транзакций

Далее мы исследовали, как транзакции "видят" изменения, вносимые друг другом, на разных уровнях изоляции. Для этого мы использовали две параллельные сессии (Т1 и Т2).

- **`READ COMMITTED` (используется в PostgreSQL по умолчанию)**:
    - **"Грязное чтение" (Dirty Read)**: Мы убедились, что в PostgreSQL невозможно прочитать "грязные" данные, то есть изменения, которые еще не были зафиксированы (не прошел `COMMIT`) в другой транзакции. T2 не увидел обновленные данные из Т1, пока Т1 не выполнила `COMMIT`.
    - **"Неповторяющееся чтение" (Non-Repeatable Read)**: Мы продемонстрировали, что если в одной транзакции (Т1) дважды прочитать одни и те же данные, результат может отличаться. Это происходит, если другая транзакция (Т2) в промежутке между чтениями успела изменить эти данные и зафиксировать их.

- **`REPEATABLE READ`**:
    - **Защита от "неповторяющегося чтения"**: На этом уровне изоляции мы показали, что T1 будет видеть одну и ту же версию данных на протяжении всей транзакции, даже если T2 изменит их и зафиксирует. Это обеспечивает более стабильное представление данных.
    - **"Фантомное чтение" (Phantom Read)**: Мы обнаружили, что даже `REPEATABLE READ` не защищает от появления "фантомов" — новых строк, которые были добавлены и зафиксированы другой транзакцией (Т2) и которые соответствуют условию выборки в нашей транзакции (Т1).

- **`SERIALIZABLE` (самый строгий уровень)**:
    - **Предотвращение конфликтов**: Мы смоделировали ситуацию, когда две транзакции пытаются вставить одинаковые данные. Та, что пытается зафиксировать изменения второй, получает ошибку сериализации (`could not serialize access`) и автоматически откатывается. Это гарантирует, что результат параллельного выполнения транзакций будет таким же, как если бы они выполнялись строго последовательно.

## 3. Точки сохранения (SAVEPOINT)

В конце мы изучили, как можно управлять изменениями внутри одной большой транзакции.

- **`SAVEPOINT`**: Мы создали "точку сохранения" после выполнения части операций.
- **`ROLLBACK TO SAVEPOINT`**: Затем мы выполнили еще несколько изменений и использовали команду `ROLLBACK TO SAVEPOINT`, чтобы отменить только те изменения, которые были сделаны *после* точки сохранения, оставив при этом в силе все, что было сделано *до* нее.
- **Несколько точек сохранения**: Мы также создали несколько точек и показали, как можно откатываться к любой из них, получая гранулярный контроль над изменениями внутри транзакции.
